프로그램을 실행하면 메뉴를 선택하라는 말과 함께 총 11개의 메뉴와 각각에 대한 설명이 나옵니다.
사실 배열로 모든 기능을 구현하려 했으나 tweet한 단어를 배열에 넣는 과정에서 이차원 char배열의 크기가 너무 커서 그런지
계속해서 오류가 뜨는 바람에 word를 저장하는 기능을 구현하지 못해서 0번과 1번, 3번 그리고 99번밖에 구현을 하지 못했습니다.
0번을 누르면 우선 파일들에서 정보를 불러옵니다.
user.txt라는 파일에서는 총 유저의 수를 세고, friend.txt라는 파일에서는 총 친구관계의 수를 셉니다. 그리고 word.txt라는 파일에서는
트위터에 올린 단어의 총 갯수와 누가 올렸는지를 세어줍니다.
그리고 총 유저의 수, 총 친구관계의 수, 그리고 트위터에 올린 총 단어의 갯수를 출력해줍니다.
1번을 누르면 0번을 통해 불러온 정보들을 정리해줍니다.
이 정리에 앞서서 0번에서 배열을 하나 만들어주는데 유저의 id가 저장되게 됩니다.
예를 들어서 ID가 1,2,3의 3명이 있다고 할 때 크기가 3인 배열을 만들어서 USERID를 각각 저장해줍니다. ARR[0] = 1, ARR[1] = 2, ARR[2] = 3
과 같이 들어가게 될 것입니다.
그리고 friend.txt에서 정보를 불러올 때 등장한 아이디를 useridcnt라는 새로운 배열에 저장해줍니다.
예를 들어서 1이라는 아이디가 등장했다면, ARR[0]이 1이므로 useridcnt[0]의 값이 1 증가하게 되는 식입니다.
tweet.txt에서도 마찬가지로 어떤 사람이 tweet을 했을 때, 그 사람의 ID에 해당하는 인덱스가 n이라면, usertweet[n]의 값이
1 증가하게 되는 식입니다. 예를 들어서 2라는 아이디가 tweet을 했다면 ARR[1]이 2이므로 usertweet[1]의 값이 1 증가하게 되는 식입니다.
이러한 방법을 통해서 각 유저의 친구수와 tweet수를 모두 배열에 저장해 준 뒤, 첫번째 원소를 max(or min)으로 지정해주어서
모든 원소와 비교를 해주는 것입니다. max(min)보다 그 원소가 더 크다면(작다면) max(min)에 그 원소를 대입하면서 모든 원소와 비교를
해줍니다. 처음에는 선택정렬을 통해 정렬을 한 후 최대와 최솟값을 구하려고 했으나 그것보다는 이 방법이 O(n)으로 더 빠르므로
이 방법을 선택하였습니다.
그리고 3번을 누르면, 위에서 만든 유저의 id배열과 tweet수의 배열 두 가지가 있을 때 tweet수의 배열을 선택정렬을 해줍니다. 이 때
정렬할 때 tweet배열의 값만 바꾸는 것이 아니라 유저의 id배열의 값까지 바꿔줍니다. 이렇게 해서 유저의 id배열의 처음 5개의 id를
읽어와서 가장 많이 tweet을 한 유저를 구해줍니다.
그리고 마지막으로 99번을 누르면 프로그램을 종료합니다.
이상입니다.
